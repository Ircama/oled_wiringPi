// SSD1306 OLED 1,3" 128x64 Pixel I2C
// https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf

#include <argp.h>
#include <wiringPi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SDA_PIN 22  // Data pin
#define SCL_PIN 23  // Clock pin
#define M_DELAY 5 // I2C default microdelay
#define TOTAL_PAGES 8 // 8 pages for 64 pixels; pages 0 to 7. Set to 4 for the 128x32 version.
// Each page is 8 pixels high, and has 128 vertical strips 1 pixel wide
#define FONT_WIDE 5 // usie 5x7 fonts in 5x8-bit matrix

#define COL_OFFSET 2
    // Correct column offset: move by 2 pixels to align properly
    // The SSD1306's addressing uses 6 pixels per character space, but the
    // actual font is 5 pixels wide. Adding 2 pixels initially ensures that
    // the character aligns correctly at the start of the column.

#define OLED_WIDTH 128    // SSD1306 width in pixels
#define OLED_HEIGHT 64    // SSD1306 height in pixels

// OLED I2C address (change if needed)
#define OLED_I2C_ADDR 0x3C

int sda_pin = SDA_PIN;
int scl_pin = SCL_PIN;
int m_delay = M_DELAY;

void i2c_start(void) {
    pinMode(sda_pin, OUTPUT);
    pinMode(scl_pin, OUTPUT);

    digitalWrite(sda_pin, HIGH);
    digitalWrite(scl_pin, HIGH);
    delayMicroseconds(m_delay);
    digitalWrite(sda_pin, LOW);
    delayMicroseconds(m_delay);
    digitalWrite(scl_pin, LOW);
}

void i2c_stop(void) {
    pinMode(sda_pin, OUTPUT);
    pinMode(scl_pin, OUTPUT);

    digitalWrite(sda_pin, LOW);
    digitalWrite(scl_pin, LOW);
    delayMicroseconds(m_delay);
    digitalWrite(scl_pin, HIGH);
    delayMicroseconds(m_delay);
    digitalWrite(sda_pin, HIGH);
    delayMicroseconds(m_delay);
}

void i2c_write_byte(unsigned char byte) {
    for (int i = 0; i < 8; i++) {
        digitalWrite(sda_pin, (byte & 0x80) ? HIGH : LOW);
        delayMicroseconds(m_delay);
        digitalWrite(scl_pin, HIGH);
        delayMicroseconds(m_delay);
        digitalWrite(scl_pin, LOW);
        byte <<= 1;
    }

    // Acknowledge bit
    pinMode(sda_pin, INPUT);
    digitalWrite(scl_pin, HIGH);
    delayMicroseconds(m_delay);
    digitalWrite(scl_pin, LOW);
    pinMode(sda_pin, OUTPUT);
}

void oled_send_command(unsigned char command) {
    i2c_start();
    i2c_write_byte(OLED_I2C_ADDR << 1); // Write mode (I2C address left-shifted by 1)
    i2c_write_byte(0x00); // Control byte for command mode
    i2c_write_byte(command); // Send the command byte
    i2c_stop();
}

void oled_send_data(unsigned char data) {
    i2c_start();
    i2c_write_byte(OLED_I2C_ADDR << 1); // Write mode (I2C address left-shifted by 1)
    i2c_write_byte(0x40); // Control byte for data mode
    i2c_write_byte(data); // Send the data byte
    i2c_stop();
}

void oled_init_SSD1306(void) {
    oled_send_command(0xAE); // Display OFF
    oled_send_command(0xD5); // Set display clock divide ratio/oscillator frequency
    oled_send_command(0x80); // Default suggested value (0x80)
    oled_send_command(0xA8); // Set multiplex ratio
    oled_send_command(0x3F); // 1/64 duty (for 128x64 OLED). Set to 0x1f for the 128x32 version

    oled_send_command(0xD3); // Set display offset
    oled_send_command(0x00); // No offset
    oled_send_command(0x40); // Set display start line (0x40 | 0x00 for line 0)

    oled_send_command(0x8D); // Enable charge pump regulator
    oled_send_command(0x14); // Enable charge pump

    oled_send_command(0xA1); // Set segment re-map (A1 for 128x64 OLED)
    oled_send_command(0xC8); // Set COM output scan direction (C8 for remapped)

    oled_send_command(0xDA); // Set COM pins hardware configuration
    oled_send_command(0x12); // Alternative COM configuration for 128x64. Set to 0x02 for the 128x32 version

    oled_send_command(0x81); // Set contrast control
    oled_send_command(0x7F); // Contrast value (0x7F is recommended)

    oled_send_command(0xD9); // Set pre-charge period
    oled_send_command(0xF1); // Default value (0x22 for SSD1306)

    oled_send_command(0xDB); // Set VCOMH deselect level
    oled_send_command(0x40); // Default value (0x40)

    oled_send_command(0xA4); // Entire display ON (resume to RAM content)
    oled_send_command(0xA6); // Normal display mode (not inverted)

    oled_send_command(0x20); // Set memory addressing mode
    oled_send_command(0x00); // Horizontal addressing mode

    oled_send_command(0xAF); // Display ON
}

/*
The size of the RAM is 128 x 64 bits and the RAM is divided into eight pages,
from PAGE0 to PAGE7, which are used for monochrome 128x64 dot matrix display.
*/

void oled_clear_SSD1306(void) {
    //oled_send_command(0xAE); // Display OFF

    // Send the common commands to set the column address range
    oled_send_command(0x21);              // Set column address
    oled_send_command(0x00);              // Start column address (0x00)
    oled_send_command(0x7F);              // End column address (0x7F for 128 pixels)

    for (int page = 0; page < TOTAL_PAGES; page++) {
        oled_send_command(0xB0 + page);     // Set page address (0xB0-0xB7)

        // Send a block of 132 zeroes in one go to clear the page
        for (int col = 0; col < 132; col++) {
            oled_send_data(0x00);  // Send zero to clear the screen
        }
    }

    //oled_send_command(0xAF); // Display ON
}

// 5x7 font data for characters - each character is 5 bits wide, 7 bits high
// The character matrix is 5x8 bits, with 255 chars (total matrix is 255x5x8 bits).
const unsigned char font[] = {
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
	0x18, 0x3C, 0x7E, 0x3C, 0x18,
	0x1C, 0x57, 0x7D, 0x57, 0x1C,
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
	0x00, 0x18, 0x3C, 0x18, 0x00,
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
	0x00, 0x18, 0x24, 0x18, 0x00,
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
	0x30, 0x48, 0x3A, 0x06, 0x0E,
	0x26, 0x29, 0x79, 0x29, 0x26,
	0x40, 0x7F, 0x05, 0x05, 0x07,
	0x40, 0x7F, 0x05, 0x25, 0x3F,
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
	0x7F, 0x3E, 0x1C, 0x1C, 0x08,
	0x08, 0x1C, 0x1C, 0x3E, 0x7F,
	0x14, 0x22, 0x7F, 0x22, 0x14,
	0x5F, 0x5F, 0x00, 0x5F, 0x5F,
	0x06, 0x09, 0x7F, 0x01, 0x7F,
	0x00, 0x66, 0x89, 0x95, 0x6A,
	0x60, 0x60, 0x60, 0x60, 0x60,
	0x94, 0xA2, 0xFF, 0xA2, 0x94,
	0x08, 0x04, 0x7E, 0x04, 0x08,
	0x10, 0x20, 0x7E, 0x20, 0x10,
	0x08, 0x08, 0x2A, 0x1C, 0x08,
	0x08, 0x1C, 0x2A, 0x08, 0x08,
	0x1E, 0x10, 0x10, 0x10, 0x10,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
	0x30, 0x38, 0x3E, 0x38, 0x30,
	0x06, 0x0E, 0x3E, 0x0E, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C, // A
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46,
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02,
	0x3C, 0x26, 0x23, 0x26, 0x3C,
	0x1E, 0xA1, 0xA1, 0x61, 0x12,
	0x3A, 0x40, 0x40, 0x20, 0x7A,
	0x38, 0x54, 0x54, 0x55, 0x59,
	0x21, 0x55, 0x55, 0x79, 0x41,
	0x21, 0x54, 0x54, 0x78, 0x41,
	0x21, 0x55, 0x54, 0x78, 0x40,
	0x20, 0x54, 0x55, 0x79, 0x40,
	0x0C, 0x1E, 0x52, 0x72, 0x12,
	0x39, 0x55, 0x55, 0x55, 0x59,
	0x39, 0x54, 0x54, 0x54, 0x59,
	0x39, 0x55, 0x54, 0x54, 0x58,
	0x00, 0x00, 0x45, 0x7C, 0x41,
	0x00, 0x02, 0x45, 0x7D, 0x42,
	0x00, 0x01, 0x45, 0x7C, 0x40,
	0xF0, 0x29, 0x24, 0x29, 0xF0,
	0xF0, 0x28, 0x25, 0x28, 0xF0,
	0x7C, 0x54, 0x55, 0x45, 0x00,
	0x20, 0x54, 0x54, 0x7C, 0x54,
	0x7C, 0x0A, 0x09, 0x7F, 0x49,
	0x32, 0x49, 0x49, 0x49, 0x32,
	0x32, 0x48, 0x48, 0x48, 0x32,
	0x32, 0x4A, 0x48, 0x48, 0x30,
	0x3A, 0x41, 0x41, 0x21, 0x7A,
	0x3A, 0x42, 0x40, 0x20, 0x78,
	0x00, 0x9D, 0xA0, 0xA0, 0x7D,
	0x39, 0x44, 0x44, 0x44, 0x39,
	0x3D, 0x40, 0x40, 0x40, 0x3D,
	0x3C, 0x24, 0xFF, 0x24, 0x24,
	0x48, 0x7E, 0x49, 0x43, 0x66,
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
	0xFF, 0x09, 0x29, 0xF6, 0x20,
	0xC0, 0x88, 0x7E, 0x09, 0x03,
	0x20, 0x54, 0x54, 0x79, 0x41,
	0x00, 0x00, 0x44, 0x7D, 0x41,
	0x30, 0x48, 0x48, 0x4A, 0x32,
	0x38, 0x40, 0x40, 0x22, 0x7A,
	0x00, 0x7A, 0x0A, 0x0A, 0x72,
	0x7D, 0x0D, 0x19, 0x31, 0x7D,
	0x26, 0x29, 0x29, 0x2F, 0x28,
	0x26, 0x29, 0x29, 0x29, 0x26,
	0x30, 0x48, 0x4D, 0x40, 0x20,
	0x38, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x38,
	0x2F, 0x10, 0xC8, 0xAC, 0xBA,
	0x2F, 0x10, 0x28, 0x34, 0xFA,
	0x00, 0x00, 0x7B, 0x00, 0x00,
	0x08, 0x14, 0x2A, 0x14, 0x22,
	0x22, 0x14, 0x2A, 0x14, 0x08,
	0xAA, 0x00, 0x55, 0x00, 0xAA,
	0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0xFF, 0x00,
	0x10, 0x10, 0x10, 0xFF, 0x00,
	0x14, 0x14, 0x14, 0xFF, 0x00,
	0x10, 0x10, 0xFF, 0x00, 0xFF,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x14, 0x14, 0x14, 0xFC, 0x00,
	0x14, 0x14, 0xF7, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x14, 0x14, 0xF4, 0x04, 0xFC,
	0x14, 0x14, 0x17, 0x10, 0x1F,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0x1F, 0x00,
	0x10, 0x10, 0x10, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0xF0, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0xFF, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x14,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0x1F, 0x10, 0x17,
	0x00, 0x00, 0xFC, 0x04, 0xF4,
	0x14, 0x14, 0x17, 0x10, 0x17,
	0x14, 0x14, 0xF4, 0x04, 0xF4,
	0x00, 0x00, 0xFF, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x14, 0x14, 0xF7, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x17, 0x14,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0xF4, 0x14,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x00, 0x00, 0x1F, 0x10, 0x1F,
	0x00, 0x00, 0x00, 0x1F, 0x14,
	0x00, 0x00, 0x00, 0xFC, 0x14,
	0x00, 0x00, 0xF0, 0x10, 0xF0,
	0x10, 0x10, 0xFF, 0x10, 0xFF,
	0x14, 0x14, 0x14, 0xFF, 0x14,
	0x10, 0x10, 0x10, 0x1F, 0x00,
	0x00, 0x00, 0x00, 0xF0, 0x10,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // full
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x38, 0x44, 0x44, 0x38, 0x44,
	0x7C, 0x2A, 0x2A, 0x3E, 0x14,
	0x7E, 0x02, 0x02, 0x06, 0x06,
	0x02, 0x7E, 0x02, 0x7E, 0x02,
	0x63, 0x55, 0x49, 0x41, 0x63,
	0x38, 0x44, 0x44, 0x3C, 0x04,
	0x40, 0x7E, 0x20, 0x1E, 0x20,
	0x06, 0x02, 0x7E, 0x02, 0x02,
	0x99, 0xA5, 0xE7, 0xA5, 0x99,
	0x1C, 0x2A, 0x49, 0x2A, 0x1C,
	0x4C, 0x72, 0x01, 0x72, 0x4C,
	0x30, 0x4A, 0x4D, 0x4D, 0x30,
	0x30, 0x48, 0x78, 0x48, 0x30,
	0xBC, 0x62, 0x5A, 0x46, 0x3D,
	0x3E, 0x49, 0x49, 0x49, 0x00,
	0x7E, 0x01, 0x01, 0x01, 0x7E,
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
	0x44, 0x44, 0x5F, 0x44, 0x44,
	0x40, 0x51, 0x4A, 0x44, 0x40,
	0x40, 0x44, 0x4A, 0x51, 0x40,
	0x00, 0x00, 0xFF, 0x01, 0x03,
	0xE0, 0x80, 0xFF, 0x00, 0x00,
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36,
	0x06, 0x0F, 0x09, 0x0F, 0x06,
	0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x00,
	0x30, 0x40, 0xFF, 0x01, 0x01,
	0x00, 0x1F, 0x01, 0x01, 0x1E,
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

void oled_display_text(const char *text, int line, int column, int spacing) {

    // Calculate default positions if not provided
    int text_length = strlen(text);
    if (column < 0) {
        column = (OLED_WIDTH - (text_length * (FONT_WIDE + spacing))) / 2; // Center horizontally
    }
    if (line < 0) {
        line = (OLED_HEIGHT / 8) / 2; // Center vertically (page-based)
    }

    // Ensure column and line are within valid ranges
    if (column < 0 || column >= OLED_WIDTH) return;
    if (line < 0 || line >= (OLED_HEIGHT / 8)) return;

    column += COL_OFFSET; // Correct column offset

    // Set the column address range
    oled_send_command(0x21);              // Set column address command
    oled_send_command(column);            // Start column address
    oled_send_command(OLED_WIDTH - 1);    // End column address (0x7F for 128 pixels)

    oled_send_command(0xB0 + line);          // Set page address (page number)
    oled_send_command(column & 0x0F);       // Set lower column address
    oled_send_command(0x10 | (column >> 4)); // Set higher column address

    while (*text) {
        // New line (wrap line and column 0) if ^n
        if ((*text == '^') && (*(text + 1) == 'n')) {
            text += 2;
            column = COL_OFFSET;
            line++;
            oled_send_command(0xB0 + line); // Set new page address
            oled_send_command(column & 0x0F);       // Set lower column address
            oled_send_command(0x10 | (column >> 4)); // Set higher column address
            continue;
        }

        // Carriage return (reset to column 0 without wrapping line) if ^r
        if ((*text == '^') && (*(text + 1) == 'r')) {
            text += 2;
            column = COL_OFFSET;
            oled_send_command(column & 0x0F);       // Set lower column address
            oled_send_command(0x10 | (column >> 4)); // Set higher column address
            continue;
        }

        // Up one line if ^u
        if ((*text == '^') && (*(text + 1) == 'u')) {
            text += 2;
            line--;
            oled_send_command(0xB0 + line); // Set new page address
            continue;
        }

        // Down one line if ^d
        if ((*text == '^') && (*(text + 1) == 'd')) {
            text += 2;
            line++;
            oled_send_command(0xB0 + line); // Set new page address
            continue;
        }

        // backspace if ^b
        if ((*text == '^') && (*(text + 1) == 'b')) {
            text += 2;
            column--;
            oled_send_command(column & 0x0F);       // Set lower column address
            oled_send_command(0x10 | (column >> 4)); // Set higher column address
            continue;
        }

        if ((*text == '^') && (*(text + 1) == '^')) {
            text += 1;
        }

        for (int i = 0; i < FONT_WIDE; i++) {
            oled_send_data(font[(*text) * FONT_WIDE + i]); // Send character
        }
        for (int i=0;i<spacing;i++)
            oled_send_data(0x00); // Spacing

        // Move to the next character
        text++;

        // Check for horizontal overflow (wrap text if necessary)
        column += (FONT_WIDE + spacing);  // FONT_WIDE pixels for character + spacing
        if (column + FONT_WIDE > OLED_WIDTH) {
            // Move to the next line (page)
            column = COL_OFFSET;
            line++;
            if (line >= OLED_HEIGHT / 8) {
                // Prevent exceeding vertical limit
                return;
            }
            oled_send_command(0xB0 + line); // Set new page address
            oled_send_command(column & 0x0F);       // Set lower column address
            oled_send_command(0x10 | (column >> 4)); // Set higher column address
        }
    }
}

// Define options
const char *argp_program_version = "oled_display 1.0";
const char *argp_program_bug_address = NULL;
static char doc[] = "Send text data to SSD1306/SH1106 OLED Display via I2C";
static char args_doc[] = ""; // No positional arguments

// Options structure
static struct argp_option options[] = {
    {"delay",    'd', "NUM",  0, "Set I2C delay (numeric)"},
    {"sda",      'a', "NUM",  0, "Set I2C SDA (numeric)"},
    {"scl",      'k', "NUM",  0, "Set I2C SCL (numeric)"},
    {"line",     'l', "NUM",  0, "Set the line number (numeric)"},
    {"column",   'c', "NUM",  0, "Set the column number (numeric)"},
    {"spacing",  's', "NUM",  0, "Set the spacing value (numeric)"},
    {"text",     't', "TEXT", 0, "Set the text (string)"},
    {"no-clear", 'n', 0, 0, "Do not clear the screen", 0},
    {0}
};

// Program arguments
struct arguments {
    int m_delay;
    int sda;
    int scl;
    int line;
    int column;
    int spacing;
    char *text;
    int clear_screen;
};

// Parse a single option
static error_t parse_opt(int key, char *arg, struct argp_state *state) {
    struct arguments *arguments = state->input;

    switch (key) {
        case 'd':
            arguments->m_delay = atoi(arg);
            break;
        case 'a':
            arguments->sda = atoi(arg);
            break;
        case 'k':
            arguments->scl = atoi(arg);
            break;
        case 'l':
            arguments->line = atoi(arg);
            break;
        case 'n':
            arguments->clear_screen = 0;
            break;
        case 'c':
            arguments->column = atoi(arg);
            break;
        case 's':
            arguments->spacing = atoi(arg);
            break;
        case 't':
            arguments->text = arg;
            break;
        case ARGP_KEY_ARG:
            // Handle non-option arguments (if any)
            return ARGP_ERR_UNKNOWN;
        case ARGP_KEY_END:
            // End of parsing
            break;
        default:
            return ARGP_ERR_UNKNOWN;
    }
    return 0;
}

// Argp parser
static struct argp argp = {options, parse_opt, args_doc, doc};

int main(int argc, char *argv[]) {

    struct arguments arguments;

    // Default values
    arguments.m_delay = M_DELAY;
    arguments.sda = SDA_PIN;
    arguments.scl = SCL_PIN;
    arguments.line = -1;
    arguments.column = -1;
    arguments.spacing = 1;
    arguments.clear_screen = 1;
    arguments.text = "Please wait...";

    // Parse command-line arguments
    argp_parse(&argp, argc, argv, 0, 0, &arguments);

    sda_pin = arguments.sda;
    scl_pin = arguments.scl;
    m_delay = arguments.m_delay;

    if (wiringPiSetupGpio() == -1) {
        fprintf(stderr, "Failed to initialize wiringPi\n");
        return EXIT_FAILURE;
    }

    pinMode(sda_pin, OUTPUT);
    pinMode(scl_pin, OUTPUT);

    oled_init_SSD1306();
    if (arguments.clear_screen)
        oled_clear_SSD1306();
    oled_display_text(arguments.text, arguments.line, arguments.column, arguments.spacing);

    // Print results
    /*
    printf("Line: %d\n", arguments.line);
    printf("Column: %d\n", arguments.column);
    printf("Spacing: %d\n", arguments.spacing);
    printf("Text: %s\n", arguments.text ? arguments.text : "(none)");
    */

    return EXIT_SUCCESS;
}
