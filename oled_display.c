#include <argp.h>
#include <wiringPi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define SDA_PIN 22  // Data pin
#define SCL_PIN 23  // Clock pin
#define M_DELAY 5 // I2C default microdelay

#define OLED_WIDTH 128    // SSD1306 width in pixels
#define OLED_HEIGHT 64    // SSD1306 height in pixels

// OLED I2C address (change if needed)
#define OLED_I2C_ADDR 0x3C

int sda_pin = SDA_PIN;
int scl_pin = SCL_PIN;
int m_delay = M_DELAY;

void i2c_start(void) {
    pinMode(sda_pin, OUTPUT);
    pinMode(scl_pin, OUTPUT);

    digitalWrite(sda_pin, HIGH);
    digitalWrite(scl_pin, HIGH);
    delayMicroseconds(m_delay);
    digitalWrite(sda_pin, LOW);
    delayMicroseconds(m_delay);
    digitalWrite(scl_pin, LOW);
}

void i2c_stop(void) {
    pinMode(sda_pin, OUTPUT);
    pinMode(scl_pin, OUTPUT);

    digitalWrite(sda_pin, LOW);
    digitalWrite(scl_pin, LOW);
    delayMicroseconds(m_delay);
    digitalWrite(scl_pin, HIGH);
    delayMicroseconds(m_delay);
    digitalWrite(sda_pin, HIGH);
    delayMicroseconds(m_delay);
}

void i2c_write_byte(unsigned char byte) {
    for (int i = 0; i < 8; i++) {
        digitalWrite(sda_pin, (byte & 0x80) ? HIGH : LOW);
        delayMicroseconds(m_delay);
        digitalWrite(scl_pin, HIGH);
        delayMicroseconds(m_delay);
        digitalWrite(scl_pin, LOW);
        byte <<= 1;
    }

    // Acknowledge bit
    pinMode(sda_pin, INPUT);
    digitalWrite(scl_pin, HIGH);
    delayMicroseconds(m_delay);
    digitalWrite(scl_pin, LOW);
    pinMode(sda_pin, OUTPUT);
}

void oled_send_command(unsigned char command) {
    i2c_start();
    i2c_write_byte(OLED_I2C_ADDR << 1); // Write mode (I2C address left-shifted by 1)
    i2c_write_byte(0x00); // Control byte for command mode
    i2c_write_byte(command); // Send the command byte
    i2c_stop();
}

void oled_send_data(unsigned char data) {
    i2c_start();
    i2c_write_byte(OLED_I2C_ADDR << 1); // Write mode (I2C address left-shifted by 1)
    i2c_write_byte(0x40); // Control byte for data mode
    i2c_write_byte(data); // Send the data byte
    i2c_stop();
}

void oled_init_SSD1306(void) {
    oled_send_command(0xAE); // Display OFF
    oled_send_command(0xD5); // Set display clock divide ratio/oscillator frequency
    oled_send_command(0x80); // Default suggested value (0x80)
    oled_send_command(0xA8); // Set multiplex ratio
    oled_send_command(0x3F); // 1/64 duty (for 128x64 OLED)

    oled_send_command(0xD3); // Set display offset
    oled_send_command(0x00); // No offset
    oled_send_command(0x40); // Set display start line (0x40 | 0x00 for line 0)

    oled_send_command(0x8D); // Enable charge pump regulator
    oled_send_command(0x14); // Enable charge pump

    oled_send_command(0xA1); // Set segment re-map (A1 for 128x64 OLED)
    oled_send_command(0xC8); // Set COM output scan direction (C8 for remapped)

    oled_send_command(0xDA); // Set COM pins hardware configuration
    oled_send_command(0x12); // Alternative COM configuration for 128x64

    oled_send_command(0x81); // Set contrast control
    oled_send_command(0x7F); // Contrast value (0x7F is recommended)

    oled_send_command(0xD9); // Set pre-charge period
    oled_send_command(0xF1); // Default value (0x22 for SSD1306)

    oled_send_command(0xDB); // Set VCOMH deselect level
    oled_send_command(0x40); // Default value (0x40)

    oled_send_command(0xA4); // Entire display ON (resume to RAM content)
    oled_send_command(0xA6); // Normal display mode (not inverted)

    oled_send_command(0x20); // Set memory addressing mode
    oled_send_command(0x00); // Horizontal addressing mode

    oled_send_command(0xAF); // Display ON
}

void oled_clear_SSD1306(void) {
    // Send the common commands to set the column address range
    oled_send_command(0x21);              // Set column address
    oled_send_command(0x00);              // Start column address (0x00)
    oled_send_command(0x7F);              // End column address (0x7F for 128 pixels)

    for (int page = 0; page < 8; page++) {  // 8 pages for 64 pixels
        oled_send_command(0xB0 + page);     // Set page address (0xB0-0xB7)

        // Send a block of 132 zeroes in one go to clear the page
        for (int col = 0; col < 132; col++) {
            oled_send_data(0x00);  // Send zero to clear the screen
        }
    }
}

const unsigned char font[] = {
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
	0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
	0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
	0x18, 0x3C, 0x7E, 0x3C, 0x18,
	0x1C, 0x57, 0x7D, 0x57, 0x1C,
	0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
	0x00, 0x18, 0x3C, 0x18, 0x00,
	0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
	0x00, 0x18, 0x24, 0x18, 0x00,
	0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
	0x30, 0x48, 0x3A, 0x06, 0x0E,
	0x26, 0x29, 0x79, 0x29, 0x26,
	0x40, 0x7F, 0x05, 0x05, 0x07,
	0x40, 0x7F, 0x05, 0x25, 0x3F,
	0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
	0x7F, 0x3E, 0x1C, 0x1C, 0x08,
	0x08, 0x1C, 0x1C, 0x3E, 0x7F,
	0x14, 0x22, 0x7F, 0x22, 0x14,
	0x5F, 0x5F, 0x00, 0x5F, 0x5F,
	0x06, 0x09, 0x7F, 0x01, 0x7F,
	0x00, 0x66, 0x89, 0x95, 0x6A,
	0x60, 0x60, 0x60, 0x60, 0x60,
	0x94, 0xA2, 0xFF, 0xA2, 0x94,
	0x08, 0x04, 0x7E, 0x04, 0x08,
	0x10, 0x20, 0x7E, 0x20, 0x10,
	0x08, 0x08, 0x2A, 0x1C, 0x08,
	0x08, 0x1C, 0x2A, 0x08, 0x08,
	0x1E, 0x10, 0x10, 0x10, 0x10,
	0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
	0x30, 0x38, 0x3E, 0x38, 0x30,
	0x06, 0x0E, 0x3E, 0x0E, 0x06,
	0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x5F, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x07, 0x00,
	0x14, 0x7F, 0x14, 0x7F, 0x14,
	0x24, 0x2A, 0x7F, 0x2A, 0x12,
	0x23, 0x13, 0x08, 0x64, 0x62,
	0x36, 0x49, 0x56, 0x20, 0x50,
	0x00, 0x08, 0x07, 0x03, 0x00,
	0x00, 0x1C, 0x22, 0x41, 0x00,
	0x00, 0x41, 0x22, 0x1C, 0x00,
	0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
	0x08, 0x08, 0x3E, 0x08, 0x08,
	0x00, 0x80, 0x70, 0x30, 0x00,
	0x08, 0x08, 0x08, 0x08, 0x08,
	0x00, 0x00, 0x60, 0x60, 0x00,
	0x20, 0x10, 0x08, 0x04, 0x02,
	0x3E, 0x51, 0x49, 0x45, 0x3E,
	0x00, 0x42, 0x7F, 0x40, 0x00,
	0x72, 0x49, 0x49, 0x49, 0x46,
	0x21, 0x41, 0x49, 0x4D, 0x33,
	0x18, 0x14, 0x12, 0x7F, 0x10,
	0x27, 0x45, 0x45, 0x45, 0x39,
	0x3C, 0x4A, 0x49, 0x49, 0x31,
	0x41, 0x21, 0x11, 0x09, 0x07,
	0x36, 0x49, 0x49, 0x49, 0x36,
	0x46, 0x49, 0x49, 0x29, 0x1E,
	0x00, 0x00, 0x14, 0x00, 0x00,
	0x00, 0x40, 0x34, 0x00, 0x00,
	0x00, 0x08, 0x14, 0x22, 0x41,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x00, 0x41, 0x22, 0x14, 0x08,
	0x02, 0x01, 0x59, 0x09, 0x06,
	0x3E, 0x41, 0x5D, 0x59, 0x4E,
	0x7C, 0x12, 0x11, 0x12, 0x7C, // A
	0x7F, 0x49, 0x49, 0x49, 0x36,
	0x3E, 0x41, 0x41, 0x41, 0x22,
	0x7F, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x49, 0x49, 0x49, 0x41,
	0x7F, 0x09, 0x09, 0x09, 0x01,
	0x3E, 0x41, 0x41, 0x51, 0x73,
	0x7F, 0x08, 0x08, 0x08, 0x7F,
	0x00, 0x41, 0x7F, 0x41, 0x00,
	0x20, 0x40, 0x41, 0x3F, 0x01,
	0x7F, 0x08, 0x14, 0x22, 0x41,
	0x7F, 0x40, 0x40, 0x40, 0x40,
	0x7F, 0x02, 0x1C, 0x02, 0x7F,
	0x7F, 0x04, 0x08, 0x10, 0x7F,
	0x3E, 0x41, 0x41, 0x41, 0x3E,
	0x7F, 0x09, 0x09, 0x09, 0x06,
	0x3E, 0x41, 0x51, 0x21, 0x5E,
	0x7F, 0x09, 0x19, 0x29, 0x46,
	0x26, 0x49, 0x49, 0x49, 0x32,
	0x03, 0x01, 0x7F, 0x01, 0x03,
	0x3F, 0x40, 0x40, 0x40, 0x3F,
	0x1F, 0x20, 0x40, 0x20, 0x1F,
	0x3F, 0x40, 0x38, 0x40, 0x3F,
	0x63, 0x14, 0x08, 0x14, 0x63,
	0x03, 0x04, 0x78, 0x04, 0x03,
	0x61, 0x59, 0x49, 0x4D, 0x43,
	0x00, 0x7F, 0x41, 0x41, 0x41,
	0x02, 0x04, 0x08, 0x10, 0x20,
	0x00, 0x41, 0x41, 0x41, 0x7F,
	0x04, 0x02, 0x01, 0x02, 0x04,
	0x40, 0x40, 0x40, 0x40, 0x40,
	0x00, 0x03, 0x07, 0x08, 0x00,
	0x20, 0x54, 0x54, 0x78, 0x40,
	0x7F, 0x28, 0x44, 0x44, 0x38,
	0x38, 0x44, 0x44, 0x44, 0x28,
	0x38, 0x44, 0x44, 0x28, 0x7F,
	0x38, 0x54, 0x54, 0x54, 0x18,
	0x00, 0x08, 0x7E, 0x09, 0x02,
	0x18, 0xA4, 0xA4, 0x9C, 0x78,
	0x7F, 0x08, 0x04, 0x04, 0x78,
	0x00, 0x44, 0x7D, 0x40, 0x00,
	0x20, 0x40, 0x40, 0x3D, 0x00,
	0x7F, 0x10, 0x28, 0x44, 0x00,
	0x00, 0x41, 0x7F, 0x40, 0x00,
	0x7C, 0x04, 0x78, 0x04, 0x78,
	0x7C, 0x08, 0x04, 0x04, 0x78,
	0x38, 0x44, 0x44, 0x44, 0x38,
	0xFC, 0x18, 0x24, 0x24, 0x18,
	0x18, 0x24, 0x24, 0x18, 0xFC,
	0x7C, 0x08, 0x04, 0x04, 0x08,
	0x48, 0x54, 0x54, 0x54, 0x24,
	0x04, 0x04, 0x3F, 0x44, 0x24,
	0x3C, 0x40, 0x40, 0x20, 0x7C,
	0x1C, 0x20, 0x40, 0x20, 0x1C,
	0x3C, 0x40, 0x30, 0x40, 0x3C,
	0x44, 0x28, 0x10, 0x28, 0x44,
	0x4C, 0x90, 0x90, 0x90, 0x7C,
	0x44, 0x64, 0x54, 0x4C, 0x44,
	0x00, 0x08, 0x36, 0x41, 0x00,
	0x00, 0x00, 0x77, 0x00, 0x00,
	0x00, 0x41, 0x36, 0x08, 0x00,
	0x02, 0x01, 0x02, 0x04, 0x02,
	0x3C, 0x26, 0x23, 0x26, 0x3C,
	0x1E, 0xA1, 0xA1, 0x61, 0x12,
	0x3A, 0x40, 0x40, 0x20, 0x7A,
	0x38, 0x54, 0x54, 0x55, 0x59,
	0x21, 0x55, 0x55, 0x79, 0x41,
	0x21, 0x54, 0x54, 0x78, 0x41,
	0x21, 0x55, 0x54, 0x78, 0x40,
	0x20, 0x54, 0x55, 0x79, 0x40,
	0x0C, 0x1E, 0x52, 0x72, 0x12,
	0x39, 0x55, 0x55, 0x55, 0x59,
	0x39, 0x54, 0x54, 0x54, 0x59,
	0x39, 0x55, 0x54, 0x54, 0x58,
	0x00, 0x00, 0x45, 0x7C, 0x41,
	0x00, 0x02, 0x45, 0x7D, 0x42,
	0x00, 0x01, 0x45, 0x7C, 0x40,
	0xF0, 0x29, 0x24, 0x29, 0xF0,
	0xF0, 0x28, 0x25, 0x28, 0xF0,
	0x7C, 0x54, 0x55, 0x45, 0x00,
	0x20, 0x54, 0x54, 0x7C, 0x54,
	0x7C, 0x0A, 0x09, 0x7F, 0x49,
	0x32, 0x49, 0x49, 0x49, 0x32,
	0x32, 0x48, 0x48, 0x48, 0x32,
	0x32, 0x4A, 0x48, 0x48, 0x30,
	0x3A, 0x41, 0x41, 0x21, 0x7A,
	0x3A, 0x42, 0x40, 0x20, 0x78,
	0x00, 0x9D, 0xA0, 0xA0, 0x7D,
	0x39, 0x44, 0x44, 0x44, 0x39,
	0x3D, 0x40, 0x40, 0x40, 0x3D,
	0x3C, 0x24, 0xFF, 0x24, 0x24,
	0x48, 0x7E, 0x49, 0x43, 0x66,
	0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
	0xFF, 0x09, 0x29, 0xF6, 0x20,
	0xC0, 0x88, 0x7E, 0x09, 0x03,
	0x20, 0x54, 0x54, 0x79, 0x41,
	0x00, 0x00, 0x44, 0x7D, 0x41,
	0x30, 0x48, 0x48, 0x4A, 0x32,
	0x38, 0x40, 0x40, 0x22, 0x7A,
	0x00, 0x7A, 0x0A, 0x0A, 0x72,
	0x7D, 0x0D, 0x19, 0x31, 0x7D,
	0x26, 0x29, 0x29, 0x2F, 0x28,
	0x26, 0x29, 0x29, 0x29, 0x26,
	0x30, 0x48, 0x4D, 0x40, 0x20,
	0x38, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x38,
	0x2F, 0x10, 0xC8, 0xAC, 0xBA,
	0x2F, 0x10, 0x28, 0x34, 0xFA,
	0x00, 0x00, 0x7B, 0x00, 0x00,
	0x08, 0x14, 0x2A, 0x14, 0x22,
	0x22, 0x14, 0x2A, 0x14, 0x08,
	0xAA, 0x00, 0x55, 0x00, 0xAA,
	0xAA, 0x55, 0xAA, 0x55, 0xAA,
	0x00, 0x00, 0x00, 0xFF, 0x00,
	0x10, 0x10, 0x10, 0xFF, 0x00,
	0x14, 0x14, 0x14, 0xFF, 0x00,
	0x10, 0x10, 0xFF, 0x00, 0xFF,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x14, 0x14, 0x14, 0xFC, 0x00,
	0x14, 0x14, 0xF7, 0x00, 0xFF,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x14, 0x14, 0xF4, 0x04, 0xFC,
	0x14, 0x14, 0x17, 0x10, 0x1F,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0x1F, 0x00,
	0x10, 0x10, 0x10, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0x1F, 0x10,
	0x10, 0x10, 0x10, 0xF0, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0xFF, 0x10,
	0x00, 0x00, 0x00, 0xFF, 0x14,
	0x00, 0x00, 0xFF, 0x00, 0xFF,
	0x00, 0x00, 0x1F, 0x10, 0x17,
	0x00, 0x00, 0xFC, 0x04, 0xF4,
	0x14, 0x14, 0x17, 0x10, 0x17,
	0x14, 0x14, 0xF4, 0x04, 0xF4,
	0x00, 0x00, 0xFF, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x14, 0x14,
	0x14, 0x14, 0xF7, 0x00, 0xF7,
	0x14, 0x14, 0x14, 0x17, 0x14,
	0x10, 0x10, 0x1F, 0x10, 0x1F,
	0x14, 0x14, 0x14, 0xF4, 0x14,
	0x10, 0x10, 0xF0, 0x10, 0xF0,
	0x00, 0x00, 0x1F, 0x10, 0x1F,
	0x00, 0x00, 0x00, 0x1F, 0x14,
	0x00, 0x00, 0x00, 0xFC, 0x14,
	0x00, 0x00, 0xF0, 0x10, 0xF0,
	0x10, 0x10, 0xFF, 0x10, 0xFF,
	0x14, 0x14, 0x14, 0xFF, 0x14,
	0x10, 0x10, 0x10, 0x1F, 0x00,
	0x00, 0x00, 0x00, 0xF0, 0x10,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // full
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0xFF, 0xFF, 0xFF, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xFF, 0xFF,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	0x38, 0x44, 0x44, 0x38, 0x44,
	0x7C, 0x2A, 0x2A, 0x3E, 0x14,
	0x7E, 0x02, 0x02, 0x06, 0x06,
	0x02, 0x7E, 0x02, 0x7E, 0x02,
	0x63, 0x55, 0x49, 0x41, 0x63,
	0x38, 0x44, 0x44, 0x3C, 0x04,
	0x40, 0x7E, 0x20, 0x1E, 0x20,
	0x06, 0x02, 0x7E, 0x02, 0x02,
	0x99, 0xA5, 0xE7, 0xA5, 0x99,
	0x1C, 0x2A, 0x49, 0x2A, 0x1C,
	0x4C, 0x72, 0x01, 0x72, 0x4C,
	0x30, 0x4A, 0x4D, 0x4D, 0x30,
	0x30, 0x48, 0x78, 0x48, 0x30,
	0xBC, 0x62, 0x5A, 0x46, 0x3D,
	0x3E, 0x49, 0x49, 0x49, 0x00,
	0x7E, 0x01, 0x01, 0x01, 0x7E,
	0x2A, 0x2A, 0x2A, 0x2A, 0x2A,
	0x44, 0x44, 0x5F, 0x44, 0x44,
	0x40, 0x51, 0x4A, 0x44, 0x40,
	0x40, 0x44, 0x4A, 0x51, 0x40,
	0x00, 0x00, 0xFF, 0x01, 0x03,
	0xE0, 0x80, 0xFF, 0x00, 0x00,
	0x08, 0x08, 0x6B, 0x6B, 0x08,
	0x36, 0x12, 0x36, 0x24, 0x36,
	0x06, 0x0F, 0x09, 0x0F, 0x06,
	0x00, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x00, 0x10, 0x10, 0x00,
	0x30, 0x40, 0xFF, 0x01, 0x01,
	0x00, 0x1F, 0x01, 0x01, 0x1E,
	0x00, 0x19, 0x1D, 0x17, 0x12,
	0x00, 0x3C, 0x3C, 0x3C, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0x00
};

void oled_display_text(const char *text, int line, int column, int spacing) {

    // Calculate default positions if not provided
    int text_length = strlen(text);
    if (column < 0) {
        column = (OLED_WIDTH - (text_length * 6)) / 2; // Center horizontally
    }
    if (line < 0) {
        line = (OLED_HEIGHT / 8) / 2; // Center vertically (page-based)
    }

    // Ensure column and line are within valid ranges
    if (column < 0 || column >= OLED_WIDTH) return;
    if (line < 0 || line >= (OLED_HEIGHT / 8)) return;

    // Correct column offset: move by 2 pixels to align properly
    // The SSD1306's addressing uses 6 pixels per character space, but the
    // actual font is 5 pixels wide. Adding 2 pixels initially ensures that
    // the character aligns correctly at the start of the column.
    column += 2;

    // Set the column address range
    oled_send_command(0x21);              // Set column address command
    oled_send_command(column);            // Start column address
    oled_send_command(OLED_WIDTH - 1);    // End column address (0x7F for 128 pixels)

    oled_send_command(0xB0 + line);          // Set page address (page number)
    oled_send_command(column & 0x0F);       // Set lower column address
    oled_send_command(0x10 | (column >> 4)); // Set higher column address

    while (*text) {
        for (int i = 0; i < 5; i++) {
            oled_send_data(font[(*text) * 5 + i]); // Send character
        }
        for (int i=0;i<spacing;i++)
            oled_send_data(0x00); // Spacing

        // Move to the next character
        text++;

        // Check for horizontal overflow (wrap text if necessary)
        column += (5 + spacing);  // 5 pixels for character + spacing
        if (column + 5 > OLED_WIDTH) {
            // Move to the next line (page)
            column = 0;
            line++;
            if (line >= OLED_HEIGHT / 8) {
                // Prevent exceeding vertical limit
                return;
            }
            oled_send_command(0xB0 + line); // Set new page address
            oled_send_command(0x00);        // Reset column address to 0
            oled_send_command(0x10);
        }
    }
}

// Define options
const char *argp_program_version = "oled_display 1.0";
const char *argp_program_bug_address = NULL;
static char doc[] = "Send text data to SSD1306/SH1106 OLED Display via I2C";
static char args_doc[] = ""; // No positional arguments

// Options structure
static struct argp_option options[] = {
    {"delay",    'd', "NUM",  0, "Set I2C delay (numeric)"},
    {"sda",      'a', "NUM",  0, "Set I2C SDA (numeric)"},
    {"scl",      'k', "NUM",  0, "Set I2C SCL (numeric)"},
    {"line",     'l', "NUM",  0, "Set the line number (numeric)"},
    {"column",   'c', "NUM",  0, "Set the column number (numeric)"},
    {"spacing",  's', "NUM",  0, "Set the spacing value (numeric)"},
    {"text",     't', "TEXT", 0, "Set the text (string)"},
    {"no-clear", 'n', 0, 0, "Do not clear the screen", 0},
    {0}
};

// Program arguments
struct arguments {
    int m_delay;
    int sda;
    int scl;
    int line;
    int column;
    int spacing;
    char *text;
    int clear_screen;
};

// Parse a single option
static error_t parse_opt(int key, char *arg, struct argp_state *state) {
    struct arguments *arguments = state->input;

    switch (key) {
        case 'd':
            arguments->m_delay = atoi(arg);
            break;
        case 'a':
            arguments->sda = atoi(arg);
            break;
        case 'k':
            arguments->scl = atoi(arg);
            break;
        case 'l':
            arguments->line = atoi(arg);
            break;
        case 'n':
            arguments->clear_screen = 0;
            break;
        case 'c':
            arguments->column = atoi(arg);
            break;
        case 's':
            arguments->spacing = atoi(arg);
            break;
        case 't':
            arguments->text = arg;
            break;
        case ARGP_KEY_ARG:
            // Handle non-option arguments (if any)
            return ARGP_ERR_UNKNOWN;
        case ARGP_KEY_END:
            // End of parsing
            break;
        default:
            return ARGP_ERR_UNKNOWN;
    }
    return 0;
}

// Argp parser
static struct argp argp = {options, parse_opt, args_doc, doc};

int main(int argc, char *argv[]) {

    struct arguments arguments;

    // Default values
    arguments.m_delay = M_DELAY;
    arguments.sda = SDA_PIN;
    arguments.scl = SCL_PIN;
    arguments.line = -1;
    arguments.column = -1;
    arguments.spacing = 1;
    arguments.clear_screen = 1;
    arguments.text = "Please wait...";

    // Parse command-line arguments
    argp_parse(&argp, argc, argv, 0, 0, &arguments);

    sda_pin = arguments.sda;
    scl_pin = arguments.scl;
    m_delay = arguments.m_delay;

    if (wiringPiSetupGpio() == -1) {
        fprintf(stderr, "Failed to initialize wiringPi\n");
        return EXIT_FAILURE;
    }

    pinMode(sda_pin, OUTPUT);
    pinMode(scl_pin, OUTPUT);

    oled_init_SSD1306();
    if (arguments.clear_screen)
        oled_clear_SSD1306();
    oled_display_text(arguments.text, arguments.line, arguments.column, arguments.spacing);

    // Print results
    /*
    printf("Line: %d\n", arguments.line);
    printf("Column: %d\n", arguments.column);
    printf("Spacing: %d\n", arguments.spacing);
    printf("Text: %s\n", arguments.text ? arguments.text : "(none)");
    */

    return EXIT_SUCCESS;
}
